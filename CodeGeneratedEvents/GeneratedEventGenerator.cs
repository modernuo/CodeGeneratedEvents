using System.Collections.Generic;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;

namespace ModernUO.CodeGeneratedEvents;

public static class GeneratedEventGenerator
{
    public static readonly string Version = Assembly.GetExecutingAssembly().GetName().Version.ToString();

    public static string Generate(
        INamedTypeSymbol classSymbol,
        List<GeneratedEventWithOnEvents> generatedEventsWithOnEvents
    )
    {
        var builder = new StringBuilder();

        builder.AppendLine("// <auto-generated>");
        builder.AppendLine("//     This code was generated by the ModernUO Code Generated Events Generator tool.");
        builder.AppendLine($"//     Version: {Version}");
        builder.AppendLine("//");
        builder.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if the");
        builder.AppendLine("//     code is regenerated.");
        builder.AppendLine("// </auto-generated>");
        builder.AppendLine();

        builder.AppendLine(
            $"namespace {classSymbol.ContainingNamespace.ToDisplayString()};"
        ).AppendLine();

        builder.AppendLine($"[System.CodeDom.Compiler.GeneratedCode(\"ModernUO.CodeGeneratedEvents.Generator\", \"{Version}\")]");
        builder.AppendContainingTypes(classSymbol);

        for (var i = 0; i < generatedEventsWithOnEvents.Count; i++)
        {
            if (i > 0)
            {
                builder.AppendLine();
            }

            var generatedEventMethodWithOnEvents = generatedEventsWithOnEvents[i];
            var generatedEventMethod = generatedEventMethodWithOnEvents.GeneratedEventMethod;
            var onEventMethods = generatedEventMethodWithOnEvents.OnEventMethods;

            // Method signature
            builder.GenerateMethodSignature(generatedEventMethod, "    ")
                .AppendLine()
                .AppendLine("    {");

            var parameterInvocation = generatedEventMethod.FormatParameterInvocation();

            foreach (var method in onEventMethods)
            {
                builder.AppendLine($"        {method.ContainingType.ToDisplayString()}.{method.Name}({parameterInvocation});");
            }

            builder.AppendLine("    }");
        }

        builder.AppendLine("}");

        return builder.ToString();
    }

    private static StringBuilder GenerateMethodSignature(this StringBuilder builder, IMethodSymbol methodSymbol, string indent)
    {
        var accessor = methodSymbol.DeclaredAccessibility;
        var staticModifier = methodSymbol.IsStatic ? "static " : string.Empty;
        // Append the partial method signature
        builder.Append($"{indent}{accessor.ToFriendlyString()} {staticModifier}partial void ").Append(methodSymbol.Name);

        // Add type parameters if any
        if (methodSymbol.TypeParameters.Length > 0)
        {
            builder.Append('<');
            for (var i = 0; i < methodSymbol.TypeParameters.Length; i++)
            {
                builder.Append(methodSymbol.TypeParameters[i].ToDisplayString());
                if (i < methodSymbol.TypeParameters.Length - 1)
                {
                    builder.Append(", ");
                }
            }
            builder.Append('>');
        }

        // Append the parameters
        builder.Append('(');
        for (var i = 0; i < methodSymbol.Parameters.Length; i++)
        {
            builder.FormatParameter(methodSymbol.Parameters[i]);
            if (i < methodSymbol.Parameters.Length - 1)
            {
                builder.Append(", ");
            }
        }
        return builder.Append(')');
    }
}
